import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";
import GUI from "lil-gui";
import gsap from "gsap";

import "./style.css";

// Textures are images that will cover the surface of the geometries, there are different types of textures and you usually combine multiple
// Color (or albedo) texture is the most simple one, applied on the geometry
// Alpha is a grayscale image where white is visible, black is invisible
// Height (or displacement) is also a grayscale image, that moves the vertices to create relief, black goes down, white goes up
// Normal, adds details, uses the RGB values of the image instead of vertices to affect lighting, simulates perceived depth, has better performances than adding height textures
// Ambient Occlusion, grayscale image, add fake shadows, not physically accurate, helps to create contrast
// Metalness, grayscale image, white is metallic, black is not, mostly used for reflection
// Roughness, grayscale image, often combined with metalness, white is rough, black is smooth, used for light dissipation

// The textures (especially metalness and roughness) follow PBR principles, physically based rendering
// It uses calculations that tries to simulate realistic lighting

// UV unwrapping decides the way the texture is places on the geometry
// Each vertex will have a 2D UV coordinate on a flat plane (usually a square)
// You can see these UV coordinates in geometry.attributes.uv which is a Float32BufferAttribute, which works similar to the BufferGeometry positions
// The UV coordinates are generated by Three.js, if you make a geometry you have to specify the UV coordinates (e.g. with Blender)

// To load a texture in native JavaScript we first need to load the image
// const doorColor = new Image();
// doorColor.src = "/textures/door/color.jpg";
// const doorColorTexture = new THREE.Texture(doorColor);

// Transform the image to a Texture that's more GPU-friendly
// doorColor.onload = () => {
//   console.log("Image loaded");
//   // The texture is used on the material of the Mesh
//   doorColorTexture.needsUpdate = true;
// };

// You can use a LoadingManager to mutualize the events, useful when needing the global loading process
const loadingManager = new THREE.LoadingManager();
loadingManager.onLoad = () => {
  console.log("All textures finished loading");
};

// You can also use a TextureLoader, where one loader can create multiple textures
const textureLoader = new THREE.TextureLoader(loadingManager);
const doorColorTexture = textureLoader.load(
  "/textures/door/color.jpg",
  () => {
    // On load
  },
  () => {
    // On progress
  },
  () => {
    // On error
  }
);
const minecraftTexture = textureLoader.load("textures/minecraft.png");
// const doorAlphaTexture = textureLoader.load("/textures/door/alpha.jpg");
// const doorHeightTexture = textureLoader.load("/textures/door/height.jpg");
// const doorNormalTexture = textureLoader.load("/textures/door/normal.jpg");
// const doorAmbientOcclusionTexture = textureLoader.load(
//   "/textures/door/ambientOcclusion.jpg"
// );
// const doorMetalnessTexture = textureLoader.load("/textures/door/metalness.jpg");
// const doorRoughnessTexture = textureLoader.load("/textures/door/roughness.jpg");

// You can also transform textures
// doorColorTexture.repeat.set(4, 4);
// doorColorTexture.wrapS = THREE.RepeatWrapping; // Defines how to wrap horizontally
// doorColorTexture.wrapT = THREE.RepeatWrapping; // Defines how to wrap vertically
// doorColorTexture.offset.set(0.5, 1.5);
// doorColorTexture.rotation = 2;
// doorColorTexture.center.set(0.5, 0.5);

// Textures used as map and matcap are supposed to be encoded in sRGB
doorColorTexture.colorSpace = THREE.SRGBColorSpace;
minecraftTexture.colorSpace = THREE.SRGBColorSpace;

// Mipmapping is a technique that repeatedly creates a half sized version of a texture until it's 1 by 1
// All the textures are sent to the GPU, which decides the most appropriate version to use
// There are two types of algorithms used to do this mipmapping:
// Minification filter - happens when the texture is bigger than the surface rendered
// Magnification filter - the opposite of the minification filter
// When setting minFilter to NearestFilter we don't need mipmapping and can deactivate it
minecraftTexture.generateMipmaps = false;
// We can change the minFilter and magFilter property if the automatic values don't work
minecraftTexture.magFilter = THREE.NearestFilter; // NearestFilter has the best performance as well

// When preparing texture, the crucial things for performance are: the weight, the resolution and the data
// jpg is usually lighter due to compression, png is heavier with lossless compression
// For mipmapping it's important that your resolution can be divided by 2
// Textures support transparency, png also has an alpha channel, or you can use an alpha map
// For a normal you want the exact values of the color to prevent visual glitches, so use a lossless compression like png
// You can find textures online: poliigon.com, 3dtextures.me, arroway-textures.ch

const gui = new GUI({
  width: 200,
  title: "Debugger",
  closeFolders: true,
});

const variables = {
  cubeColor: "#74a7fe",
  cubeSubdivisions: 2,
};

const triggers = {
  rotateCube: () => {
    gsap.to(cube.rotation, { y: cube.rotation.y + Math.PI / 2 });
  },
};

const canvas = document.querySelector("canvas.three");
const scene = new THREE.Scene();
const sizes = {
  height: window.innerHeight,
  width: window.innerWidth,
};

const cube = new THREE.Mesh(
  new THREE.BoxGeometry(1, 1, 1, 2, 2, 2),
  new THREE.MeshBasicMaterial({
    map: minecraftTexture,
    // map: doorColorTexture,
    wireframe: true,
  })
);
scene.add(cube);

const cubeDebugOptions = gui.addFolder("Cube");

cubeDebugOptions
  .add(cube.position, "y")
  .name("Cube Elevation")
  .min(-3)
  .max(3)
  .step(0.01)
  .setValue(0.05);

cubeDebugOptions.add(cube, "visible").name("Cube Visibility");
cubeDebugOptions
  .add(cube.material, "wireframe")
  .name("Cube Wireframe")
  .setValue(false);

cubeDebugOptions.add(triggers, "rotateCube");

cubeDebugOptions
  .add(variables, "cubeSubdivisions")
  .name("Cube Subdivisions")
  .min(1)
  .max(10)
  .step(1)
  .onFinishChange((value) => {
    cube.geometry.dispose();
    cube.geometry = new THREE.BoxGeometry(1, 1, 1, value, value, value);
  });

const camera = new THREE.PerspectiveCamera(
  65,
  sizes.width / sizes.height,
  0.01,
  100
);
camera.position.y = 1;
camera.position.z = 3;
camera.lookAt(cube.position);
scene.add(camera);

const controls = new OrbitControls(camera, canvas);
controls.enableDamping = true;

const renderer = new THREE.WebGLRenderer({ canvas });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(sizes.width, sizes.height);

let time = Date.now();

const tick = () => {
  const currentTime = Date.now();
  const deltaTime = currentTime - time;
  time = currentTime;

  controls.update(0.005 * deltaTime);

  renderer.render(scene, camera);
  window.requestAnimationFrame(tick);
};

tick();

window.addEventListener("resize", (e) => {
  sizes.height = e.target.window.innerHeight;
  sizes.width = e.target.window.innerWidth;

  camera.aspect = sizes.width / sizes.height;
  camera.updateProjectionMatrix();

  renderer.setSize(sizes.width, sizes.height);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
});
